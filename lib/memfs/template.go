// Copyright 2019, Shulhan <ms@kilabit.info>. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package memfs

import (
	"fmt"
	"text/template"

	"github.com/shuLhan/share/lib/ascii"
	libbytes "github.com/shuLhan/share/lib/bytes"
)

func generateTemplate() (tmpl *template.Template, err error) {
	var textTemplate = `{{ define "HEADER" -}}
// Code generated by github.com/shuLhan/share/lib/memfs DO NOT EDIT.

package {{.}}

import (
	"github.com/shuLhan/share/lib/memfs"
)
{{end}}
{{define "GENERATE_NODE"}}
func generate{{ funcname .Path | printf "%s"}}() *memfs.Node {
	node := &memfs.Node{
		SysPath:     "{{.SysPath}}",
		Path:        "{{.Path}}",
		Name:        "{{.Name}}",
		ContentType: "{{.ContentType}}",
		Mode:        {{printf "%d" .Mode}},
		Size:        {{.Size}},
{{- if .V }}
		V: []byte{
			{{range $x, $c := .V}}{{ if maxline $x }}{{ printf "\n\t\t\t" }}{{else if $x}} {{end}}{{ printf "%d," $c }}{{end}}
		},
{{- end }}
	}
	memfs.GeneratedPathNode.Set("{{.Path}}", node)
	return node
}
{{end}}
{{define "PATHFUNCS"}}
func init() {
	memfs.GeneratedPathNode = memfs.NewPathNode()
{{- range $path, $node := .}}
	memfs.GeneratedPathNode.SetFunc("{{$path}}", generate{{funcname $node.Path | printf "%s" }})
{{- end}}
}
{{end}}
`
	tmplFuncs := template.FuncMap{
		"funcname": func(path string) []byte {
			return libbytes.InReplace([]byte(path), []byte(ascii.LettersNumber), '_')
		},
		"maxline": func(x int) bool {
			if x != 0 && x%16 == 0 {
				return true
			}
			return false
		},
	}

	tmpl, err = template.New("memfs").Funcs(tmplFuncs).Parse(textTemplate)
	if err != nil {
		return nil, fmt.Errorf("memfs: GoGenerate: " + err.Error())
	}

	return tmpl, nil
}
