// Copyright 2019, Shulhan <ms@kilabit.info>. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package memfs

import (
	"fmt"
	"os"
	"text/template"

	libbytes "github.com/shuLhan/share/lib/bytes"
)

func generateTemplate() (tmpl *template.Template, err error) {
	var textTemplate = `{{ define "HEADER" -}}
// Code generated by github.com/shuLhan/share/lib/memfs DO NOT EDIT.

package {{.}}

import (
	"os"
)

var pathNode = map[string]*Node{}

//
// Node represent a single file.
//
type Node struct {
	SysPath     string      // The original file path in system.
	Path        string      // Absolute file path in memory.
	Name        string      // File name.
	ContentType string      // File type per MIME, e.g. "application/json".
	Mode        os.FileMode // File mode.
	Size        int64       // Size of file.
	V           []byte      // Content of file.
	Parent      *Node       // Pointer to parent directory.
	Childs      []*Node     // List of files in directory.
}

//
// Get node at path, or nil if path is not exist.
//
func Get(path string) *Node {
	node, ok := pathNode[path]
	if ok {
		return node
	}
	f, ok := pathFuncs[path]
	if ok {
		return f()
	}
	return nil
}
{{end}}
{{define "GENERATE_NODE"}}
func generate{{ funcname .Path | printf "%s"}}() *Node {
	node := &Node{
		SysPath:     "{{.SysPath}}",
		Path:        "{{.Path}}",
		Name:        "{{.Name}}",
		ContentType: "{{.ContentType}}",
		Mode:        {{printf "%d" .Mode}},
		Size:        {{.Size}},
{{- if isdir .Mode }}
		V:           []byte{},
	}
{{- else }}
		V: []byte{
			{{range $x, $c := .V}}{{ if maxline $x }}{{ printf "\n\t\t\t" }}{{else if $x}} {{end}}{{ printf "%d," $c }}{{end}}
		},
	}
{{ end }}
	pathNode["{{.Path}}"] = node
	return node
}
{{end}}
{{define "PATHFUNCS"}}
{{- $maxlen := pathlen . }}
var pathFuncs = map[string]func() *Node{
{{- range $path, $node := .}}
	"{{$path}}":{{pad $maxlen $path | printf "%s"}}generate{{funcname $node.Path | printf "%s"}},
{{- end}}
}
{{end}}
`

	tmplFuncs := template.FuncMap{
		"funcname": func(path string) []byte {
			return libbytes.InReplace([]byte(path), []byte(libbytes.ASCIILettersNumber), '_')
		},
		"maxline": func(x int) bool {
			if x != 0 && x%16 == 0 {
				return true
			}
			return false
		},
		"isdir": func(fm os.FileMode) bool {
			return fm.IsDir()
		},
		"pathlen": func(paths map[string]*Node) (l int) {
			for k := range paths {
				if l < len(k) {
					l = len(k)
				}
			}
			return
		},
		"pad": func(maxlen int, path string) (spaces []byte) {
			spaces = make([]byte, 0, maxlen-len(path))
			for x := 0; x <= maxlen-len(path); x++ {
				spaces = append(spaces, ' ')
			}
			return
		},
	}

	tmpl, err = template.New("memfs").Funcs(tmplFuncs).Parse(textTemplate)
	if err != nil {
		return nil, fmt.Errorf("memfs: GoGenerate: " + err.Error())
	}

	return tmpl, nil
}
